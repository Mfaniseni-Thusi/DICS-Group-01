## Use these commands to run:
cd Rust
cargo run
python main.py

## Rust code explanation

For simplification, the use of .par_iter() in Rayon allows automatic parallel iteration over a data collection, distributing work across available CPU cores. This approach abstracts away the explicit management of thread pools or core allocation, letting the library efficiently utilize the system's concurrency capabilities based on runtime conditions and workload characteristics. The number of cores are directly related to how many .par_iter()'s are used. 

The timings of the different functions are recorded into a CSV file, which is then analysed using a python script called main.py. This python script will compute the percentages (quicker or slower) and it will create a graph to better visualise the data.

---------- 2-D implementation ----------

### multiply_sequential()

Everything ran sequentially as per mathematical equations.

### multiply_2_core()

For each row in the first matrix, the dot product with every row of the transposed second matrix (stored in b_transposed) is computed in parallel.
The rest is computed in series. 

### multiply_3_core()

- Parallel Part 1:
Utilizes .par_iter() on self.data to parallelize the computation across each row of the resulting matrix.
This parallelization ensures that the processing of different rows of the first matrix can occur simultaneously.

- Parallel Part 2:
Applies b_transposed.par_iter() for iterating over the rows of the transposed second matrix in parallel.
Enables concurrent computation of dot products for a single row in the first matrix against all rows of the transposed second matrix.

- Parallel Part 3:
Executes the dot product calculation in parallel using a_row.par_iter().zip(b_row).map(|(a_val, b_val)| a_val * b_val).sum().
This step ensures that the multiplication and subsequent addition operations required to compute a single dot product are also carried out in parallel.

---------- 3-D implementation ----------

### multiply_sequential()

This method iterates through the layers and performs 2D matrix multiplication without parallelism.

### multiply_2_core()

- Parallel Part 1: 
Multiplication is parallelized at the layer level, iterating through each 2D matrix layer in parallel.

### multiply_3_core()

- Parallel Part 2:
As above with...
The 3D matrix is divided into chunks, and each chunk's layers are processed in parallel. Within each layer, the 2D matrix multiplication is sequential.

### multiply_4_core()

- Parallel Part 3:
As above with...
The highest parallelism level by not only iterating through each layer in parallel but also performing the dot product calculations within each 2D matrix multiplication in parallel.